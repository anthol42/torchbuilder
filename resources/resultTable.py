import pandas as pd
import os
from pathlib import PurePath
from datetime import datetime
import json
"""
# The Result Table Concept:
    The Result Table concept state that results should be stored once and be unalterable afterward.  This preserved the 
    integrity of and reproducibility of results.  Based on this definition, each result stored in a Result Table must not
    be overwritten nor deleted.  New results are only appended to the end of the table.
    To keep tract of experiments, they are indexed with the experiment name, the config file name and the hyperparameters.
    
    Q & A:
        Q: What happen if I redo an experiment with exact same name, config file and hyperparameters?
        A: You should not do this!  If you already run the exact same experiment, the results will be the same except is
           you have some sort of randomness.  In this situation, we strongly suggest to add a parameter representing the 
           number of time the experiment is run.  By doing so, only one experiment will run multiple time the 
           underlying experiment to produce statistics.  In fact, you should never run again an experiment that has 
           already been run since it would overwrite the results of the previous experiment, thus preventing 
           results integrity.
        
"""

class Table:
    """
    This class implement the Result Table concept.  The way it works is to firstly create a table with the TableBuilder
    class.  (This is done only once, see TableBuilder documentation for more info).  Once the table is created, we can
    use the Table object.  We only need to specify the path of the result table that we are using to create an instance
    of the table.  You must not create more than one instance of the same table since there would be conflicts when
    saving.  Then, we can register a result in the table.  Each line/results in a table are called records.
    It is strongly suggested to register records at the beginning of the script since it will stop the program if the
    experiment has already been done, thus preventing the run of two identical jobs.  Next, if the job is unique and no
    errors are thrown, this method will return a RecordSocket.  RecordSockets are the object you program will interact
    with.  They are directly connected to the table, but are limited to write in their allocated space.  this prevents
    data corruption.  In addition, to add a layer of security, RecordSockets can be used only once.  This means that
    once the results are written, they cannot be updated.  This improves data authenticity.  This explication was the
    basic usage of Results Tables.  When using the write method, you must pass EVERY metrics recorded in the Table at
    it's construction by the TableBuilder.  Metrics are passed as keywords arguments (kwargs) to the write method and
    must not contain spelling errors.

    How to use:
        1. Create a table with TableBuilder (see documentation)
        2. Load your table at the beginning of the script.
        3. Register the result and retrieve the RecordSocket. (At the begining of the script)
        4. Use the RecordSocket to write the final results at the end of the experiment.  (Note that this can only be done once.)

    In addtition:
        - Adding a category: use the add_category method
        - Export to excel/csv/json: use the export method that will export to a pandas dataframe.  Then, you can save it in any format.

    Notes:
        Every action is saved automatically.

    Examples:
        >>>### Begining of the script ###

        >>># This assumes that the table has already been built with two categories: CNN and Transformers

        >>># In addition, there is two metrics that are recorded in the table: crossEntropy and F1

        >>>table = Table("rtable.json")

        >>>socket = table.registerRecord("CNNTest1", "CNN1.yaml", category="CNN", dataset="Huge")

        >>>### End of scripts, when experiment is done and results are collected ###

        >>>socket.write(crossEntropy=val_loss, F1=val_score)

        >>># Trying to write again to socket will result in an error:

        >>> socket.write(crossEntropy=val_loss2, F1=val_score2) # Raise exception: AttributeError

        >>># Add categories --> Usually done in the script that build the table since we usually don't add categories on the fly.

        >>>table.add_category("GAN") # Automatically saved

        >>># Export result table to csv:

        >>>table.export().to_csv("results/result_table.csv") # The export method convert the Table to pandas DataFrame.

        >>># Export result table to csv:

        >>>table.toTxt("results/CompiledResults.txt")

    """
    def __init__(self, path, debug=False):
        """
        Initialize the Table class
        :param path: Path to the saved table.  (Must be a json file generated by the TableBuilder class)
        :param path: If debug, the save function is deactivated.  This way, it is possible to run many times the same
                     experiment for debugging.
        """
        with open(path, 'r') as file:
            load_dict = json.load(file)

        self.allow_update = load_dict['metadata']['allow_update']
        self.path = path
        self.name = load_dict['metadata']['name']
        self.timeCreated = load_dict['metadata']['timeCreated']
        self.format = load_dict['metadata']['format']
        self.round_decimal = load_dict['preferences']['round_decimal']
        self.DEBUG = debug

        self.metrics = load_dict['metrics']
        self.records = load_dict['records']
        if len(self.records.keys()) == 0:
            self.records["defaultCategory"] = []

    class RecordSocket:
        """
        This is a class used to write result in its reserved spaced in the result table.  It's a unique usage class.
        This means that once the write method is called, the write method is no longer available.
        """
        def __init__(self, record:dict, metrics: list, saving_func):
            self.record = record
            self.save = saving_func
            self.active = True
            self.metrics = metrics

        def write(self, **kwargs):
            """
            Write results to the table
            :param kwargs: metrics to pass to the table.  Need to pass ALL the metrics at the same time.
            :return: None
            """
            if self.active:
                if set(self.metrics) != set(kwargs.keys()):
                    print(set(self.metrics), set(kwargs.keys()))
                    raise ValueError("Registered metrics and passed metrics are not the same!")
                for key, value in kwargs.items():
                    self.record[key] = value
                self.record['LastModified'] = str(datetime.now())
                self.record["Filled"] = True
                self.save()
                self.active = False
            else:
                raise AttributeError("This record socket has already been written to.  Create an other one or create a "
                                     "new record to write again!")
        def __str__(self):
            s = f"{self.record['name']}<RecordSocket>\n"
            max_len = len(s)
            for metric in self.metrics:
                if self.record.get(metric) is not None:
                    toAppend = f"\t{metric}: {self.record[metric]}\n"
                    s += toAppend
                    if len(toAppend) > max_len:
                        max_len = toAppend
                else:
                    toAppend = f"\t{metric}: None\n"
                    s += toAppend
                    if len(toAppend) > max_len:
                        max_len = toAppend
            s += "-"*max_len
            return s

    def format_hyper(self, hyperparameters:dict) -> str:
        hyper_str = [f"{key}:{value}" for key, value in hyperparameters.items()]
        return "\n".join(hyper_str)

    def registerRecord(self, experiment_name: str, config_file_name: str, category: str = None, **hyperparameters):
        """
        Register a place in the table where to store metrics from experiment.
        :param experiment_name: Name of the experiment
        :param config_file_name: Name of the config file
        :param category: The category where to put it, if no category is provided, it will store it in the default category
        :param hyperparameters: Hyperparameters are passed as kwargs.  Since we use a config file, for most
                                cases, it is usually empty.  It is possible to add as kwargs hyperparameters
                                that we plan to change a lot to try different combination.  This way, we don't have to
                                make a new config file with almost every thing identical to other s except one
                                hyperparameter.
        :return: TableSocket, the object with which it is possible to write results to the Table.
        """
        if category and category not in self.records.keys():
            raise ValueError("Invalid category name")
        if not category:
            category = "defaultCategory"
        hyper_format = self.format_hyper(hyperparameters)
        record_state = 'CREATED'
        record_idx = None
        # Verify if experiment already exist to avoid creating a duplicate
        for i, record in enumerate(self.records[category]):
            if record['name'] == experiment_name and \
                    record['hyperparameters'] == hyper_format and \
                    record['config'] == config_file_name:
                if self.allow_update:
                    record_state = 'UPDATE'
                    record_idx = i
                    break
                else:
                    raise ValueError("Experiment already exits!")
        if record_state == 'UPDATE':
             self.records[category][record_idx]['status'] = record_state
        else:
            record_idx = -1
            self.records[category].append({
                "RunId": self.create_run_id(),
                "name": experiment_name,
                "config": config_file_name,
                "hyperparameters": hyper_format,
                "status": record_state,
                "LastModified":datetime.now(),
                "Filled":False
            })
        return self.RecordSocket(self.records[category][record_idx], self.metrics, self.save)
    def create_run_id(self):
        max_id = 0
        for cat in self.records.values():
            for record in cat:
                if record["RunId"] > max_id:
                    max_id = record["RunId"]

        return max_id + 1

    def add_category(self, category_name: str):
        """
        Add a category to the table.  Usually used in the table builder scripts
        :param category_name: The name of the category to add
        :return: None
        """
        if category_name in self.records.keys():
            raise ValueError("Category already exist.")
        self.records[category_name] = []
        self.save()

    def save(self):
        """
        Internal function.  YOU MUST NOT USE IT!!!!
        :return:
        """
        table = {
            "metadata": {
                "name": self.name,
                "timeCreated": self.timeCreated,
                "format": self.format,
                "allow_update": self.allow_update
            },
            "preferences":{
                "round_decimal":self.round_decimal
            },
            "metrics": self.metrics,
            "records": self.records
        }
        if not self.DEBUG:
            with open(self.path, 'w') as file:
                json.dump(table, file)

    def export(self):
        """
        Export to pands' DataFrame
        :return: pandas.DataFrame
        """
        columns = ["RunId", "Category", "Experiment", "Hyperparameters", "Configuration"] + self.metrics + ["Status", "Last Modified"]
        data = []
        for categoryName, categoryContent in self.records.items():
            for record in categoryContent:
                rec = [record["RunId"], categoryName, record["name"], record["hyperparameters"], record["config"]]
                for metric_name in self.metrics:
                    rec.append(record[metric_name])
                rec += [record["status"], record["LastModified"]]
                data.append(rec)

        df = pd.DataFrame(data=data, columns=columns)
        df = df.set_index(df["RunId"])
        df.index.name = 'Run Id'
        return df

    def __str__(self):
        pd.set_option('display.max_rows', 500)
        pd.set_option('display.max_columns', 500)
        pd.set_option('display.width', 1000)
        df = self.export()
        def formtHyper(x):
            x_list = x.split("\n")
            if len(x_list) > 3:
                return ", ".join(x_list[:3]) + ", ..."
            else:
                return ", ".join(x_list)
        df["Hyperparameters"] = df["Hyperparameters"].apply(formtHyper)
        df["Category"] = df["Category"].apply(lambda x: "" if x == "defaultCategory" else x)
        df = df.drop(columns=["RunId"])
        df = df.groupby("Category", group_keys=True).apply(lambda x: x).drop(columns=["Category"])
        return str(df)

    def toTxt(self, filepath="results/CompiledResults.txt"):
        """
        Save file in a visually nice looking text format (lossy).  It is lossy since it might round numbers and may not
        display everything to make results interpretable in a glance. If you want more precision and make a complete
        anlysis, consider the export method.
        :param filepath: Filepath to save file
        :return: None
        """
        with open(filepath, "w") as file:
            file.write(str(self))



class TableBuilder:
    """
    This class can create a result table of the class Table.  This class must be in a script that will be run only
    one time to create the table.  Every future attempts will result in exception since you cannot create a new table
    to override the old one.  (Table are designed to be unalterable.  See Table's documentation for more info.)

    How to use:
      1. Initiate a TableBuilder object with desired options (The metrics you want to include* and the path where to
         save the table**)
      2. Call the build method of the builder only once to build the table. The method will return the created Table.
      3. Add categories.

      * You need to pass every metrics you want to include in this table since you cannot add any later.  Note that
        every metric you add will be require with every records.  (Empty cell are not allowed)
      ** Note that table are saved automatically so pick a location that can handle a lot of read/write.

    Examples:
        >>># Build a table with F1 and crossEntropy as metrics values.  (Same as the Table's example.

        >>>table = TableBuilder(["F1", "crossEntropy"], PurePath("rtable.json")).build() # We save the table to path: rtable.json

        >>># Add categories to the table.

        >>>table.add_category("CNN")

        >>>table.add_category("Transformer")
    """
    def __init__(self, metrics_names: list, path: PurePath, round_decimal: int = 3, allow_update=False):
        """
        Create a new TableBuilder, an object made to create new resultTables.
        :param metrics_names: A list containing strings that correspond to the names of the metrics to include.
        :param path: The path(with the name) to the Table to be created.
                     It must be a location that handle a lot of read/write
        :param round_decimal: The number of precision decimal to keep when rounding the results
        :param allow_update: Whether to make the records updatable or unalterable.  It is strongly suggested to never
               allow updates.
        """
        self.metrics = metrics_names
        self.path = path
        self.name = path.name
        self.round_decimal = round_decimal
        self.allow_update = allow_update
        if not os.path.exists(path.parent):
            os.makedirs(path.parent)
        if os.path.exists(self.path):
            raise FileExistsError("The table has already been created!")

    def build(self) -> Table:
        """
        Builds the table, save it and return it.
        :return: The newly created Table
        """
        if os.path.exists(self.path):
            raise FileExistsError("The table has already been built!")
        table = {
            "metadata":{
                "name": self.name,
                "timeCreated": str(datetime.now()),
                "format": "JSON",
                "allow_update": self.allow_update
            },
            "preferences":{
                "round_decimal":self.round_decimal
            },
            "metrics": self.metrics,
            "records": {}
        }
        with open(self.path, 'w') as file:
            json.dump(table, file)
        return Table(path=self.path)

if __name__ == "__main__":
    ### To make the example runnable more than once, I reset the table at every run.  Do not do this in experimentation!

    ## In table builder script (Should be in an auxiliary file) ##
    if os.path.exists("rtable.json"):
        os.remove("rtable.json")
    table = TableBuilder(["F1", "crossEntropy"], PurePath("rtable.json")).build()
    table.add_category("CNN")
    table.add_category("Transformer")
    ## End of builder script ##

    ## Example of what will happen in an experiment script ##

    table = Table("rtable.json")
    socket = table.registerRecord("CNNTest1", "CNN1.yaml", category="CNN", dataset="Huge")

    # End of script:
    print("writing")
    socket.write(crossEntropy=0.42, F1=0.98)

    # Export to csv
    table.export().to_csv("result_table.csv")